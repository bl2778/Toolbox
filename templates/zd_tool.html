<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zero-Defect Analysis - Analytics Toolbox</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <!-- Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    </head>
<body>
    <div class="app-shell">
        <header class="app-header">
            <div class="container header-container">
                <a href="/dashboard" class="app-brand" aria-label="Bain Toolbox home">
                    <span class="app-brand-mark" aria-hidden="true">üîß</span>
                    <span class="app-brand-text">Bain Toolbox</span>
                </a>
                <nav class="app-nav" aria-label="Primary navigation">
                    <a href="/dashboard" class="nav-link">Dashboard</a>
                    <a href="/transcription" class="nav-link">Transcription</a>
                    <a href="/wr" class="nav-link">Wording Revision</a>
                    <a href="/logout" class="nav-link logout-btn">Logout</a>
                </nav>
            </div>
        </header>

        <main class="app-main container">
        <!-- Header -->
        <header class="card page-header">
            <h1 class="title">Zero-Defect Analysis</h1>
            <p class="subtitle">Check your PowerPoint presentations for spelling mistakes, grammar issues, and logic inconsistencies</p>

            <div class="header-actions">
                <a href="/dashboard" class="btn btn-secondary btn-inline">
                    ‚Üê Back to Dashboard
                </a>
            </div>
        </header>

        <!-- Upload Form -->
        <section class="card section-card" id="uploadForm">
            <h2 class="section-title">Upload PowerPoint File</h2>

            <form id="zdUploadForm" enctype="multipart/form-data">
                <div class="zd-form-group">
                    <label>Select PowerPoint File (.pptx)</label>
                    <div class="zd-file-input-wrapper">
                        <div class="zd-file-input" id="fileDropZone">
                            <input type="file" id="pptFile" name="ppt_file" accept=".pptx" style="display: none;">
                            <div id="fileSelectText">
                                üìÅ Click to select or drag & drop your .pptx file here
                            </div>
                        </div>
                    </div>
                </div>

                <div class="zd-form-group">
                    <label>Analysis Mode</label>
                    <div class="zd-mode-selection">
                        <div class="zd-mode-card selected" data-mode="fast">
                            <h4>‚ö° Fast Mode</h4>
                            <p>4,000-6,500 words per batch<br>Up to 10 pages per chunk<br>Lower cost, faster processing</p>
                        </div>
                        <div class="zd-mode-card" data-mode="precise">
                            <h4>Precise Mode</h4>
                            <p>2,500-4,000 words per batch<br>Up to 5 pages per chunk<br>More thorough cross-page logic checking</p>
                        </div>
                    </div>
                </div>

                <div class="zd-form-group">
                    <label>Document Language</label>
                    <div class="zd-model-selection">
                        <select id="languageSelect" name="language">
                            <option value="english">English</option>
                            <option value="chinese">Chinese</option>
                        </select>
                    </div>
                </div>

                <div class="zd-form-group">
                    <label>AI Model</label>
                    <div class="zd-model-selection">
                        <select id="modelSelect" name="model">
                            <option value="gpt-5">GPT-5 (Recommended)</option>
                            <option value="gpt-5-thinking">GPT-5 Thinking</option>
                            <option value="gpt-4.5">GPT-4.5</option>
                            <option value="gpt-5-pro">GPT-5 Pro</option>
                            <option value="gpt-4">GPT-4</option>
                            <option value="deepseek-chat">Deepseek Chat</option>
                            <option value="deepseek-reasoner">Deepseek Reasoner</option>
                        </select>
                    </div>
                </div>

                <button type="submit" class="btn btn-full" id="startAnalysisBtn" disabled>
                    Start Analysis
                </button>
            </form>
        </section>

        <!-- Progress Display -->
        <div class="card zd-progress-container" id="progressContainer">
            <h2>Analysis Progress</h2>

            <div class="zd-status-display">
                <div class="zd-progress-bar">
                    <div class="zd-progress-fill" id="progressFill"></div>
                </div>
                <div id="statusMessage">Initializing...</div>
                <div id="progressText">0%</div>
                <button class="btn btn-small btn-inline btn-top-space" onclick="toggleDebugSection()">
                    üêõ Toggle Debug
                </button>
            </div>

            <div id="chunksInfo" class="zd-chunks-info"></div>

            <!-- Debug Section -->
            <div class="zd-debug-section" id="debugSection" style="display: none;">
                <h3>üêõ Debug Information</h3>
                <div class="zd-debug-buttons">
                    <button class="btn btn-small" onclick="loadDebugInfo()">Load Debug Info</button>
                    <button class="btn btn-small" onclick="loadRawResults()">Load Raw Results</button>
                    <button class="btn btn-small" onclick="testParseResults()">üß™ Test Parse</button>
                    <button class="btn btn-small" onclick="clearDebugOutput()">Clear</button>
                    <button class="btn btn-small" onclick="toggleDebugSection()">Hide Debug</button>
                </div>
                <div class="zd-debug-output" id="debugOutput">Click "Load Debug Info" to see detailed information...</div>
            </div>
        </div>

        <!-- Results Display -->
        <section class="card zd-results-container" id="resultsContainer">
            <div class="zd-results-header">
                <h2>Analysis Results</h2>
                <div class="zd-export-buttons">
                    <button class="btn btn-small" id="exportCsvBtn">Export CSV</button>
                    <button class="btn btn-small" id="exportExcelBtn">üìà Export Excel</button>
                </div>
            </div>

            <div id="resultsStats" class="info-line"></div>

            <div class="zd-filter-controls">
                <label>
                    <input type="checkbox" id="filterIssuesOnly" checked>
                    Show only pages with issues
                </label>
                <label>
                    <input type="checkbox" id="filterLogicOnly">
                    Show only logic issues
                </label>
                <button class="btn btn-small btn-inline btn-gap-start" onclick="forceShowDebugInfo()">
                    Force Debug
                </button>
            </div>

            <div id="resultsTableContainer">
                <table class="zd-results-table" id="resultsTable">
                    <colgroup>
                        <col style="width: 50px;">   <!-- Á¨¨1ÂàóÔºöPage No. ÂèòÁ™Ñ -->
                        <col style="width: 30%;">    <!-- Á¨¨2ÂàóÔºöSpelling ÂÆΩ‰∏ÄÁÇπ -->
                        <col style="width: 40%;">    <!-- Á¨¨3ÂàóÔºöGrammar -->
                        <col style="width: 30%;">    <!-- Á¨¨4ÂàóÔºöLogic -->
                    </colgroup>
                    <thead>
                        <tr>
                            <th class="zd-page-header">P.</th>
                            <th class="zd-spelling-header">Spelling</th>
                            <th class="zd-grammar-header">Grammar</th>
                            <th class="zd-logic-header">Logic</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody">
                    </tbody>
                </table>
            </div>
        </section>
        </main>

        <footer class="app-footer">
            <div class="container footer">
                <p>¬© 2024 Bain Toolbox. All rights reserved.</p>
            </div>
        </footer>
    </div>

    <script>
        let currentJobId = null;
        let currentMode = 'fast';
        let statusPollInterval = null;

        // File upload handling
        const fileInput = document.getElementById('pptFile');
        const fileDropZone = document.getElementById('fileDropZone');
        const fileSelectText = document.getElementById('fileSelectText');
        const startAnalysisBtn = document.getElementById('startAnalysisBtn');

        fileDropZone.addEventListener('click', () => fileInput.click());

        fileDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileDropZone.classList.add('dragover');
        });

        fileDropZone.addEventListener('dragleave', () => {
            fileDropZone.classList.remove('dragover');
        });

        fileDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            fileDropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                fileInput.files = files;
                updateFileDisplay();
            }
        });

        fileInput.addEventListener('change', updateFileDisplay);

        function updateFileDisplay() {
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                fileSelectText.innerHTML = `${file.name} (${formatFileSize(file.size)})`;
                startAnalysisBtn.disabled = false;
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Mode selection
        document.querySelectorAll('.zd-mode-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('.zd-mode-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                currentMode = card.dataset.mode;
            });
        });

        // Form submission
        document.getElementById('zdUploadForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            await startAnalysis();
        });

        async function startAnalysis() {
            try {
                // Step 1: Upload file
                const formData = new FormData();
                formData.append('ppt_file', fileInput.files[0]);

                const uploadResponse = await fetch('/api/zd/jobs', {
                    method: 'POST',
                    body: formData
                });

                const uploadResult = await uploadResponse.json();

                if (!uploadResult.success) {
                    throw new Error(uploadResult.error);
                }

                currentJobId = uploadResult.job_id;

                // Step 2: Start analysis
                const analysisResponse = await fetch(`/api/zd/jobs/${currentJobId}/run`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        mode: currentMode,
                        model: document.getElementById('modelSelect').value,
                        language: document.getElementById('languageSelect').value
                    })
                });

                const analysisResult = await analysisResponse.json();

                if (!analysisResult.success) {
                    throw new Error(analysisResult.error);
                }

                // Show progress and start polling
                showProgress(analysisResult);
                startStatusPolling();

            } catch (error) {
                alert(`Analysis failed: ${error.message}`);
            }
        }

        function showProgress(data) {
            document.getElementById('uploadForm').style.display = 'none';
            document.getElementById('progressContainer').style.display = 'block';

            if (data.stats) {
                const unit = data.stats.unit || 'words';
                document.getElementById('statusMessage').textContent =
                    `Analyzing ${data.stats.total_slides} slides (${data.stats.total_words} ${unit}) in ${data.total_chunks} chunks`;
            }
        }

        function startStatusPolling() {
            if (statusPollInterval) clearInterval(statusPollInterval);

            statusPollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/zd/jobs/${currentJobId}`);
                    const status = await response.json();

                    updateProgressDisplay(status);

                    if (status.status === 'done') {
                        clearInterval(statusPollInterval);
                        console.log('[DEBUG] Analysis completed, loading results...');

                        // Keep debug panel visible if it was open
                        const debugSection = document.getElementById('debugSection');
                        const wasDebugVisible = debugSection && debugSection.style.display !== 'none';

                        await loadResults();

                        // Restore debug panel visibility
                        if (wasDebugVisible && debugSection) {
                            debugSection.style.display = 'block';
                        }
                    } else if (status.status === 'error') {
                        clearInterval(statusPollInterval);
                        console.error('[DEBUG] Analysis failed:', status.error);

                        // Show error in progress container instead of hiding everything
                        const statusMessage = document.getElementById('statusMessage');
                        if (statusMessage) {
                            statusMessage.textContent = `Analysis failed: ${status.error}`;
                            statusMessage.style.color = '#dc3545';
                        }

                        alert(`Analysis failed: ${status.error}`);
                    }
                } catch (error) {
                    console.error('Error polling status:', error);
                }
            }, 2000);
        }

        function updateProgressDisplay(status) {
            const progressFill = document.getElementById('progressFill');
            const statusMessage = document.getElementById('statusMessage');
            const progressText = document.getElementById('progressText');

            progressFill.style.width = `${status.progress || 0}%`;
            progressText.textContent = `${status.progress || 0}%`;

            const statusMessages = {
                'parsing': 'Parsing PowerPoint file...',
                'chunking': 'Dividing content into chunks...',
                'prompting': 'Sending chunks to AI...',
                'thinking': 'AI is analyzing content...',
                'merging': 'Merging results...'
            };

            statusMessage.textContent = statusMessages[status.status] || status.status;

            updateChunksDisplay(status);
        }

        function updateChunksDisplay(status) {
            const chunksInfo = document.getElementById('chunksInfo');

            if (status.chunk_details) {
                // Check for new chunks that don't have UI sections yet
                Object.keys(status.chunk_details).forEach(chunkId => {
                    const existingSection = document.getElementById(`chunk-${chunkId}`);
                    if (!existingSection) {
                        // Create section for this new chunk
                        createChunkSection(chunkId, status.chunk_details[chunkId]);
                    }
                });

                // Update all existing chunk sections
                updateChunkSections(status.chunk_details);
            }
        }

        function createChunkSections(chunkDetails) {
            const chunksInfo = document.getElementById('chunksInfo');
            chunksInfo.innerHTML = '';

            // Sort chunks by chunk_id for consistent ordering
            const sortedChunks = Object.entries(chunkDetails).sort((a, b) => a[0].localeCompare(b[0]));

            sortedChunks.forEach(([chunkId, chunkData]) => {
                const chunkSection = document.createElement('div');
                chunkSection.className = 'zd-chunk-section';
                chunkSection.id = `chunk-${chunkId}`;

                const statusIcon = getStatusIcon(chunkData.status);
                const statusText = getStatusText(chunkData.status);

                chunkSection.innerHTML = `
                    <div class="zd-chunk-header ${chunkData.status}" onclick="toggleChunkDetails('${chunkId}')">
                        <div class="zd-chunk-title">
                            ${statusIcon} Chunk ${chunkId.replace('ck_', '')} (Pages ${chunkData.page_start}-${chunkData.page_end})
                        </div>
                        <div class="zd-chunk-status">
                            <span class="zd-chunk-progress">${chunkData.ai_progress || statusText}</span>
                            ${chunkData.status === 'failed' ? `<button class="zd-retry-btn" onclick="retryChunk('${chunkId}', event)">Retry</button>` : ''}
                            <span class="zd-chunk-toggle" id="toggle-${chunkId}">‚ñº</span>
                        </div>
                    </div>
                    <div class="zd-chunk-details" id="details-${chunkId}">
                        <div class="zd-chunk-info">
                            <div class="zd-chunk-info-item">
                                <strong>Pages:</strong> ${chunkData.page_start} - ${chunkData.page_end}<br>
                                <strong>Word Count:</strong> ${chunkData.word_count || 'N/A'}
                            </div>
                            <div class="zd-chunk-info-item">
                                <strong>Status:</strong> ${statusText}<br>
                                <strong>Started:</strong> ${formatTime(chunkData.start_time)}
                            </div>
                        </div>
                        ${chunkData.error ? `<div style="color: #dc3545; margin-bottom: 10px;"><strong>Error:</strong> ${chunkData.error}</div>` : ''}
                        <div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <strong>AI Streaming Output:</strong>
                                ${chunkData.status === 'completed' ? `<button class="zd-recheck-btn" onclick="recheckChunk('${chunkId}', event)" id="recheck-${chunkId}">üîÑ Re-check</button>` : ''}
                            </div>
                            <div class="zd-format-toggle">
                                <label>
                                    <input type="radio" name="format-${chunkId}" value="raw" checked onchange="toggleOutputFormat('${chunkId}', 'raw')">
                                    Raw
                                </label>
                                <label>
                                    <input type="radio" name="format-${chunkId}" value="markdown" onchange="toggleOutputFormat('${chunkId}', 'markdown')">
                                    Markdown
                                </label>
                            </div>
                            <div class="zd-streaming-output ${chunkData.streaming_output ? '' : 'empty'}" id="streaming-${chunkId}">
                                ${chunkData.streaming_output || 'No output yet...'}
                            </div>
                        </div>
                        <div class="zd-chunk-timing" id="timing-${chunkId}">
                            ${getTimingInfo(chunkData)}
                        </div>
                    </div>
                `;

                chunksInfo.appendChild(chunkSection);
            });
        }

        function createChunkSection(chunkId, chunkData) {
            const chunksInfo = document.getElementById('chunksInfo');

            const chunkSection = document.createElement('div');
            chunkSection.className = 'zd-chunk-section';
            chunkSection.id = `chunk-${chunkId}`;

            const statusIcon = getStatusIcon(chunkData.status);
            const statusText = getStatusText(chunkData.status);

            chunkSection.innerHTML = `
                <div class="zd-chunk-header ${chunkData.status}" onclick="toggleChunkDetails('${chunkId}')">
                    <div class="zd-chunk-title">
                        ${statusIcon} Chunk ${chunkId.replace('ck_', '')} (Pages ${chunkData.page_start}-${chunkData.page_end})
                    </div>
                    <div class="zd-chunk-status">
                        <span class="zd-chunk-progress">${chunkData.ai_progress || statusText}</span>
                        ${chunkData.status === 'failed' ? `<button class="zd-retry-btn" onclick="retryChunk('${chunkId}', event)">Retry</button>` : ''}
                        <span class="zd-chunk-toggle" id="toggle-${chunkId}">‚ñº</span>
                    </div>
                </div>
                <div class="zd-chunk-details" id="details-${chunkId}">
                    <div class="zd-chunk-info">
                        <div class="zd-chunk-info-item">
                            <strong>Pages:</strong> ${chunkData.page_start} - ${chunkData.page_end}<br>
                            <strong>Word Count:</strong> ${chunkData.word_count || 'N/A'}
                        </div>
                        <div class="zd-chunk-info-item">
                            <strong>Status:</strong> ${statusText}<br>
                            <strong>Started:</strong> ${formatTime(chunkData.start_time)}
                        </div>
                    </div>
                    ${chunkData.error ? `<div style="color: #dc3545; margin-bottom: 10px;"><strong>Error:</strong> ${chunkData.error}</div>` : ''}
                    <div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong>AI Streaming Output:</strong>
                            ${chunkData.status === 'completed' ? `<button class="zd-recheck-btn" onclick="recheckChunk('${chunkId}', event)" id="recheck-${chunkId}">üîÑ Re-check</button>` : ''}
                        </div>
                        <div class="zd-format-toggle">
                            <label>
                                <input type="radio" name="format-${chunkId}" value="raw" checked onchange="toggleOutputFormat('${chunkId}', 'raw')">
                                Raw
                            </label>
                            <label>
                                <input type="radio" name="format-${chunkId}" value="markdown" onchange="toggleOutputFormat('${chunkId}', 'markdown')">
                                Markdown
                            </label>
                        </div>
                        <div class="zd-streaming-output ${chunkData.streaming_output ? '' : 'empty'}" id="streaming-${chunkId}">
                            ${chunkData.streaming_output || 'No output yet...'}
                        </div>
                    </div>
                    <div class="zd-chunk-timing" id="timing-${chunkId}">
                        ${getTimingInfo(chunkData)}
                    </div>
                </div>
            `;

            // Insert the section in the correct position (sorted by chunk_id)
            const existingSections = Array.from(chunksInfo.children);
            const insertIndex = existingSections.findIndex(section => {
                const existingId = section.id.replace('chunk-', '');
                return chunkId.localeCompare(existingId) < 0;
            });

            if (insertIndex === -1) {
                chunksInfo.appendChild(chunkSection);
            } else {
                chunksInfo.insertBefore(chunkSection, existingSections[insertIndex]);
            }
        }

        function updateChunkSections(chunkDetails) {
            Object.entries(chunkDetails).forEach(([chunkId, chunkData]) => {
                const header = document.querySelector(`#chunk-${chunkId} .zd-chunk-header`);
                const progressSpan = document.getElementById(`chunk-${chunkId}`) ?
                    document.querySelector(`#chunk-${chunkId} .zd-chunk-progress`) : null;
                const streamingOutput = document.getElementById(`streaming-${chunkId}`);
                const timing = document.getElementById(`timing-${chunkId}`);
                const recheckBtn = document.getElementById(`recheck-${chunkId}`);

                if (header) {
                    // Update header status class
                    header.className = `zd-chunk-header ${chunkData.status}`;
                }

                if (progressSpan) {
                    // Update progress text
                    progressSpan.textContent = chunkData.ai_progress || getStatusText(chunkData.status);
                }

                // Update re-check button visibility and state
                if (recheckBtn) {
                    if (chunkData.status === 'completed') {
                        recheckBtn.style.display = 'block';
                        recheckBtn.disabled = false;
                        recheckBtn.textContent = 'üîÑ Re-check';
                    } else {
                        recheckBtn.style.display = 'none';
                    }
                } else if (chunkData.status === 'completed') {
                    // Button doesn't exist but chunk is completed, add it
                    const outputHeader = document.querySelector(`#details-${chunkId} div div`);
                    if (outputHeader && !outputHeader.querySelector('.zd-recheck-btn')) {
                        const button = document.createElement('button');
                        button.className = 'zd-recheck-btn';
                        button.id = `recheck-${chunkId}`;
                        button.innerHTML = 'üîÑ Re-check';
                        button.onclick = (e) => recheckChunk(chunkId, e);
                        outputHeader.appendChild(button);
                    }
                }

                if (streamingOutput) {
                    // Update streaming output
                    if (chunkData.streaming_output) {
                        // Check current format mode
                        const formatRadios = document.querySelectorAll(`input[name="format-${chunkId}"]`);
                        const isMarkdown = Array.from(formatRadios).find(r => r.checked)?.value === 'markdown';

                        if (isMarkdown && typeof marked !== 'undefined') {
                            streamingOutput.innerHTML = marked.parse(chunkData.streaming_output);
                            streamingOutput.className = 'zd-streaming-output markdown';
                        } else {
                            streamingOutput.textContent = chunkData.streaming_output;
                            streamingOutput.className = 'zd-streaming-output';
                        }
                        // Auto-scroll to bottom
                        streamingOutput.scrollTop = streamingOutput.scrollHeight;
                    } else {
                        streamingOutput.textContent = 'No output yet...';
                        streamingOutput.className = 'zd-streaming-output empty';
                    }
                }

                if (timing) {
                    // Update timing information
                    timing.innerHTML = getTimingInfo(chunkData);
                }
            });
        }

        function getStatusIcon(status) {
            const icons = {
                'starting': 'üîÑ',
                'sending': 'üì§',
                'processing': '‚ö°',
                'completed': 'Completed',
                'failed': 'Failed'
            };
            return icons[status] || '‚è≥';
        }

        function getStatusText(status) {
            const texts = {
                'starting': 'Starting...',
                'sending': 'Sending to AI...',
                'processing': 'AI Processing...',
                'completed': 'Completed',
                'failed': 'Failed'
            };
            return texts[status] || 'Unknown';
        }

        function formatTime(timestamp) {
            if (!timestamp) return 'N/A';
            const date = new Date(timestamp * 1000);
            return date.toLocaleTimeString();
        }

        function getTimingInfo(chunkData) {
            if (!chunkData.start_time) return '';

            const startTime = new Date(chunkData.start_time * 1000).toLocaleTimeString();
            let timingHtml = `Started: ${startTime}`;

            if (chunkData.completion_time) {
                const completionTime = new Date(chunkData.completion_time * 1000).toLocaleTimeString();
                const duration = ((chunkData.completion_time - chunkData.start_time) / 1000).toFixed(1);
                timingHtml += ` | Completed: ${completionTime} | Duration: ${duration}s`;
            } else if (chunkData.start_time) {
                const elapsed = ((Date.now() / 1000) - chunkData.start_time).toFixed(1);
                timingHtml += ` | Elapsed: ${elapsed}s`;
            }

            return timingHtml;
        }

        function toggleChunkDetails(chunkId) {
            const details = document.getElementById(`details-${chunkId}`);
            const toggle = document.getElementById(`toggle-${chunkId}`);

            if (details.classList.contains('expanded')) {
                details.classList.remove('expanded');
                toggle.classList.remove('expanded');
            } else {
                details.classList.add('expanded');
                toggle.classList.add('expanded');
            }
        }

        function retryChunk(chunkId, event) {
            event.stopPropagation(); // Prevent toggle

            if (confirm(`Retry chunk ${chunkId.replace('ck_', '')}?`)) {
                fetch(`/api/zd/jobs/${currentJobId}/chunks/${chunkId}/retry`, {
                    method: 'POST'
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Remove retry button and update status
                        const retryBtn = event.target;
                        retryBtn.style.display = 'none';
                    } else {
                        alert(`Retry failed: ${data.error}`);
                    }
                })
                .catch(error => {
                    alert(`Retry failed: ${error.message}`);
                });
            }
        }

        async function recheckChunk(chunkId, event) {
            event.stopPropagation(); // Prevent toggle

            if (confirm(`Re-check chunk ${chunkId.replace('ck_', '')}? This will send the chunk content to AI again and replace the existing result.`)) {
                const recheckBtn = document.getElementById(`recheck-${chunkId}`);
                const streamingOutput = document.getElementById(`streaming-${chunkId}`);

                try {
                    // Disable button and show processing state
                    recheckBtn.disabled = true;
                    recheckBtn.textContent = 'üîÑ Re-checking...';

                    // Clear current output and show loading
                    streamingOutput.textContent = 'Re-checking chunk...';
                    streamingOutput.className = 'zd-streaming-output empty';

                    // Update chunk header to show processing state
                    const header = document.querySelector(`#chunk-${chunkId} .zd-chunk-header`);
                    const progressSpan = document.querySelector(`#chunk-${chunkId} .zd-chunk-progress`);
                    if (header) header.className = 'zd-chunk-header processing';
                    if (progressSpan) progressSpan.textContent = 'Re-checking...';

                    // Make API call
                    const response = await fetch(`/api/zd/jobs/${currentJobId}/chunks/${chunkId}/recheck`, {
                        method: 'POST'
                    });

                    const data = await response.json();

                    if (data.success) {
                        // Success - button will be re-enabled when status updates come through polling
                        recheckBtn.textContent = 'üîÑ Re-check';
                    } else {
                        throw new Error(data.error || 'Re-check failed');
                    }
                } catch (error) {
                    // Error - restore button state
                    recheckBtn.disabled = false;
                    recheckBtn.textContent = 'üîÑ Re-check';
                    streamingOutput.textContent = `Re-check failed: ${error.message}`;
                    streamingOutput.className = 'zd-streaming-output';
                    alert(`Re-check failed: ${error.message}`);
                }
            }
        }

        function toggleOutputFormat(chunkId, format) {
            const streamingOutput = document.getElementById(`streaming-${chunkId}`);
            if (!streamingOutput) return;

            const content = streamingOutput.textContent || streamingOutput.innerHTML;

            if (format === 'markdown' && typeof marked !== 'undefined' && content !== 'No output yet...') {
                streamingOutput.innerHTML = marked.parse(content);
                streamingOutput.className = 'zd-streaming-output markdown';
            } else {
                streamingOutput.textContent = content;
                streamingOutput.className = 'zd-streaming-output';
            }
        }

        function toggleDebugSection() {
            const debugSection = document.getElementById('debugSection');
            const isVisible = debugSection.style.display !== 'none';
            debugSection.style.display = isVisible ? 'none' : 'block';

            if (!isVisible) {
                loadDebugInfo();
            }
        }

        async function loadDebugInfo() {
            if (!currentJobId) {
                document.getElementById('debugOutput').textContent = 'No active job to debug.';
                return;
            }

            try {
                const response = await fetch(`/api/zd/jobs/${currentJobId}/debug`);
                const debugData = await response.json();

                document.getElementById('debugOutput').textContent = JSON.stringify(debugData, null, 2);
            } catch (error) {
                document.getElementById('debugOutput').textContent = `Error loading debug info: ${error.message}`;
            }
        }

        async function loadRawResults() {
            if (!currentJobId) {
                document.getElementById('debugOutput').textContent = 'No active job to debug.';
                return;
            }

            try {
                const response = await fetch(`/api/zd/jobs/${currentJobId}/result?include_raw=true`);
                const rawData = await response.json();

                document.getElementById('debugOutput').textContent = JSON.stringify(rawData, null, 2);
            } catch (error) {
                document.getElementById('debugOutput').textContent = `Error loading raw results: ${error.message}`;
            }
        }

        async function testParseResults() {
            if (!currentJobId) {
                document.getElementById('debugOutput').textContent = 'No active job to test parsing.';
                return;
            }

            try {
                const response = await fetch(`/api/zd/jobs/${currentJobId}/test-parse`);
                const parseData = await response.json();

                let outputText = `=== PARSE TEST RESULTS ===\n\n`;
                outputText += `Job ID: ${parseData.job_id}\n`;
                outputText += `Total Chunks: ${parseData.total_chunks}\n\n`;

                for (const [chunkId, testResult] of Object.entries(parseData.test_results || {})) {
                    outputText += `--- CHUNK ${chunkId} ---\n`;
                    outputText += `Original Length: ${testResult.original_length} chars\n`;
                    outputText += `Raw Lines: ${testResult.raw_lines_count}\n`;
                    outputText += `Parsed Rows: ${testResult.parsed_rows_count}\n`;
                    outputText += `First 200 chars: ${testResult.first_200_chars}\n`;

                    if (testResult.parsed_rows && testResult.parsed_rows.length > 0) {
                        outputText += `Sample parsed rows:\n`;
                        testResult.parsed_rows.forEach(row => {
                            outputText += `  Page ${row.page_number}: Spelling="${row.spelling}" Grammar="${row.grammar}" Logic="${row.logic}"\n`;
                        });
                    } else {
                        outputText += `ERROR: NO ROWS PARSED!\n`;
                    }
                    outputText += `\n`;
                }

                document.getElementById('debugOutput').textContent = outputText;
            } catch (error) {
                document.getElementById('debugOutput').textContent = `Error testing parse: ${error.message}`;
            }
        }

        function clearDebugOutput() {
            document.getElementById('debugOutput').textContent = 'Debug output cleared.';
        }

        async function forceShowDebugInfo() {
            // Force show debug panel
            const debugSection = document.getElementById('debugSection');
            const progressContainer = document.getElementById('progressContainer');

            if (debugSection) {
                debugSection.style.display = 'block';
            }

            if (progressContainer) {
                progressContainer.style.display = 'block';
            }

            // Load both debug info and raw results
            if (currentJobId) {
                try {
                    const [debugResponse, rawResponse] = await Promise.all([
                        fetch(`/api/zd/jobs/${currentJobId}/debug`),
                        fetch(`/api/zd/jobs/${currentJobId}/result?include_raw=true`)
                    ]);

                    const debugData = await debugResponse.json();
                    const rawData = await rawResponse.json();

                    const combinedInfo = {
                        timestamp: new Date().toISOString(),
                        job_debug_info: debugData,
                        raw_results_info: {
                            has_results: !!rawData.results,
                            results_count: rawData.results ? rawData.results.length : 0,
                            has_raw_chunk_results: !!rawData.raw_chunk_results,
                            raw_chunks_count: rawData.raw_chunk_results ? Object.keys(rawData.raw_chunk_results).length : 0
                        },
                        full_raw_data: rawData
                    };

                    document.getElementById('debugOutput').textContent = JSON.stringify(combinedInfo, null, 2);
                } catch (error) {
                    document.getElementById('debugOutput').textContent = `Force debug error: ${error.message}`;
                }
            } else {
                document.getElementById('debugOutput').textContent = 'No current job ID available for debugging.';
            }
        }

        async function loadResults() {
            console.log('[DEBUG] Loading results for job:', currentJobId);

            try {
                const response = await fetch(`/api/zd/jobs/${currentJobId}/result`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('[DEBUG] Results loaded:', data);

                if (data.error) {
                    throw new Error(data.error);
                }

                displayResults(data);

            } catch (error) {
                console.error('[DEBUG] Error loading results:', error);
                alert(`Failed to load results: ${error.message}`);

                // Keep progress container visible and show error
                const statusMessage = document.getElementById('statusMessage');
                if (statusMessage) {
                    statusMessage.textContent = `Error loading results: ${error.message}`;
                    statusMessage.style.color = '#dc3545';
                }
            }
        }

        function displayResults(data) {
            // Hide progress display but keep the container visible so debug panel remains
            document.getElementById('progressFill').style.width = '100%';
            document.getElementById('statusMessage').textContent = 'Analysis Complete!';
            document.getElementById('progressText').textContent = '100%';

            // Show results container
            document.getElementById('resultsContainer').style.display = 'block';

            // Update stats
            const statsDiv = document.getElementById('resultsStats');
            if (data.stats) {
                const results = data.results || [];
                const issuesCount = results.filter(r => r.spelling || r.grammar || r.logic).length;
                const spellingCount = results.filter(r => r.spelling && r.spelling.trim()).length;
                const grammarCount = results.filter(r => r.grammar && r.grammar.trim()).length;
                const logicCount = results.filter(r => r.logic && r.logic.trim()).length;
                const unit = data.stats.unit || 'words';

                statsDiv.innerHTML = `
                    <strong>Analysis Complete!</strong>
                    Processed ${data.stats.total_slides} slides (${data.stats.total_words} ${unit}).
                    Found issues on ${issuesCount} pages.
                    <br>
                    <small>Spelling: ${spellingCount} pages ‚Ä¢ Grammar: ${grammarCount} pages ‚Ä¢ Logic: ${logicCount} pages</small>
                `;
            } else {
                statsDiv.innerHTML = `
                    <strong>Analysis Complete!</strong>
                    Results processed successfully.
                `;
            }

            console.log('[DEBUG] Displaying results:', {
                hasStats: !!data.stats,
                resultsCount: data.results ? data.results.length : 0,
                issuesCount: data.results ? data.results.filter(r => r.spelling || r.grammar || r.logic).length : 0
            });

            // Populate table
            populateResultsTable(data.results);

            // Setup export buttons
            setupExportButtons();
        }

        function populateResultsTable(results) {
            const tbody = document.getElementById('resultsTableBody');
            if (!tbody) {
                console.error('[DEBUG] Results table body not found!');
                return;
            }

            tbody.innerHTML = '';

            if (!results || results.length === 0) {
                console.log('[DEBUG] No results to display');
                const tr = document.createElement('tr');
                tr.innerHTML = '<td colspan="4" style="text-align: center; color: #6c757d; font-style: italic;">No results found. Check debug panel for details.</td>';
                tbody.appendChild(tr);
                return;
            }

            console.log('[DEBUG] Populating table with', results.length, 'results');

            const createIssueCell = (value, cellType = '') => {
                const cell = document.createElement('td');
                cell.className = `zd-issues-cell zd-${cellType}-cell`;

                if (value && value.trim() !== '') {
                    // Don't split on commas - just display the complete issue text
                    // The AI should already format issues properly for each column
                    const issueSpan = document.createElement('span');
                    issueSpan.className = `zd-issue-item zd-${cellType}-item`;
                    issueSpan.textContent = value;
                    cell.appendChild(issueSpan);
                } else {
                    const noIssuesSpan = document.createElement('span');
                    noIssuesSpan.className = 'zd-no-issues';
                    noIssuesSpan.textContent = '\u2014';
                    cell.appendChild(noIssuesSpan);
                }

                return cell;
            };


            results.forEach((row, index) => {
                console.log(`[DEBUG] Row ${index + 1} - Page ${row.page_number}: spelling="${row.spelling}", grammar="${row.grammar}", logic="${row.logic}"`);

                const tr = document.createElement('tr');

                const hasIssues = row.spelling || row.grammar || row.logic;
                if (!hasIssues) {
                    tr.style.opacity = '0.6';
                }

                // Add debug info as data attributes for easier inspection
                tr.setAttribute('data-page', row.page_number);
                tr.setAttribute('data-has-spelling', !!(row.spelling && row.spelling.trim()));
                tr.setAttribute('data-has-grammar', !!(row.grammar && row.grammar.trim()));
                tr.setAttribute('data-has-logic', !!(row.logic && row.logic.trim()));

                const pageCell = document.createElement('td');
                pageCell.className = 'zd-page-number';
                pageCell.textContent = row.page_number || 'N/A';
                tr.appendChild(pageCell);

                tr.appendChild(createIssueCell(row.spelling || '', 'spelling'));
                tr.appendChild(createIssueCell(row.grammar || '', 'grammar'));
                tr.appendChild(createIssueCell(row.logic || '', 'logic'));

                tbody.appendChild(tr);
            });

            console.log('[DEBUG] Table populated successfully');

            // Setup filtering
            setupResultsFiltering(results);
        }

        function setupResultsFiltering(results) {
            const filterIssuesOnly = document.getElementById('filterIssuesOnly');
            const filterLogicOnly = document.getElementById('filterLogicOnly');

            function applyFilters() {
                const rows = document.querySelectorAll('#resultsTableBody tr');

                rows.forEach((row, index) => {
                    const result = results[index];
                    let show = true;

                    if (filterIssuesOnly.checked) {
                        const hasIssues = result.spelling || result.grammar || result.logic;
                        if (!hasIssues) show = false;
                    }

                    if (filterLogicOnly.checked) {
                        if (!result.logic) show = false;
                    }

                    row.style.display = show ? '' : 'none';
                });
            }

            filterIssuesOnly.addEventListener('change', applyFilters);
            filterLogicOnly.addEventListener('change', applyFilters);

            // Apply initial filter
            applyFilters();
        }

        function setupExportButtons() {
            document.getElementById('exportCsvBtn').addEventListener('click', () => {
                window.open(`/api/zd/jobs/${currentJobId}/result?format=csv`);
            });

            document.getElementById('exportExcelBtn').addEventListener('click', () => {
                window.open(`/api/zd/jobs/${currentJobId}/result?format=xlsx`);
            });
        }
    </script>
</body>
</html>
