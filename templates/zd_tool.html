<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZD Tool - Bain Toolbox</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <!-- Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .zd-form-group {
            margin-bottom: 20px;
        }

        .zd-form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }

        .zd-file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .zd-file-input {
            width: 100%;
            padding: 12px;
            border: 2px dashed #007bff;
            border-radius: 8px;
            background: #f8f9fa;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .zd-file-input:hover {
            border-color: #0056b3;
            background: #e9ecef;
        }

        .zd-file-input.dragover {
            border-color: #28a745;
            background: #d4edda;
        }

        .zd-mode-selection {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }

        .zd-mode-card {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .zd-mode-card.selected {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .zd-mode-card:hover {
            border-color: #007bff;
        }

        .zd-model-selection {
            margin-top: 10px;
        }

        .zd-model-selection select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .zd-progress-container {
            display: none;
            margin-top: 20px;
        }

        .zd-progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .zd-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #0056b3);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .zd-status-display {
            text-align: center;
            margin-bottom: 15px;
        }

        .zd-chunks-info {
            margin-top: 15px;
        }

        .zd-chunk-section {
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .zd-chunk-header {
            padding: 15px;
            cursor: pointer;
            background: #f8f9fa;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s;
        }

        .zd-chunk-header:hover {
            background: #e9ecef;
        }

        .zd-chunk-header.completed {
            background: #d4edda;
        }

        .zd-chunk-header.failed {
            background: #f8d7da;
        }

        .zd-chunk-header.processing {
            background: #fff3cd;
        }

        .zd-chunk-header.sending {
            background: #cce5ff;
        }

        .zd-chunk-title {
            font-weight: bold;
            font-size: 14px;
        }

        .zd-chunk-status {
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .zd-chunk-toggle {
            font-size: 18px;
            transform: rotate(0deg);
            transition: transform 0.3s;
        }

        .zd-chunk-toggle.expanded {
            transform: rotate(180deg);
        }

        .zd-chunk-details {
            padding: 15px;
            background: white;
            display: none;
            border-top: 1px solid #ddd;
        }

        .zd-chunk-details.expanded {
            display: block;
        }

        .zd-chunk-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 15px;
        }

        .zd-chunk-info-item {
            font-size: 13px;
        }

        .zd-chunk-info-item strong {
            color: #495057;
        }

        .zd-streaming-output {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre-wrap;
            margin-top: 10px;
        }

        .zd-streaming-output.markdown {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            white-space: normal;
        }

        .zd-streaming-output.markdown table {
            border-collapse: collapse;
            width: 100%;
            font-size: 11px;
        }

        .zd-streaming-output.markdown th,
        .zd-streaming-output.markdown td {
            border: 1px solid #dee2e6;
            padding: 4px 8px;
            text-align: left;
        }

        .zd-streaming-output.markdown th {
            background: #e9ecef;
            font-weight: bold;
        }

        .zd-streaming-output.empty {
            color: #6c757d;
            font-style: italic;
            text-align: center;
        }

        .zd-retry-btn {
            padding: 5px 10px;
            font-size: 12px;
            background: #ffc107;
            color: #000;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }

        .zd-retry-btn:hover {
            background: #e0a800;
        }

        .zd-chunk-timing {
            font-size: 11px;
            color: #6c757d;
            margin-top: 10px;
        }

        .zd-results-container {
            display: none;
            margin-top: 20px;
        }

        .zd-results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .zd-export-buttons {
            display: flex;
            gap: 10px;
        }

        .zd-results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .zd-results-table th {
            background: #007bff;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }

        .zd-results-table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
            vertical-align: top;
        }

        .zd-results-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .zd-results-table tr:hover {
            background: #e9ecef;
        }

        .zd-page-number {
            font-weight: bold;
            color: #007bff;
            min-width: 60px;
        }

        .zd-issues-cell {
            max-width: 300px;
            word-wrap: break-word;
        }

        .zd-no-issues {
            color: #6c757d;
            font-style: italic;
        }

        .zd-logic-issue {
            color: #dc3545;
            font-weight: bold;
        }

        .zd-filter-controls {
            margin-bottom: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .zd-filter-controls label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }

        .btn-small {
            padding: 5px 10px;
            font-size: 12px;
            border-radius: 4px;
        }

        .btn-retry {
            background: #ffc107;
            color: #000;
        }

        .btn-retry:hover {
            background: #e0a800;
        }

        .hidden {
            display: none;
        }

        .zd-debug-section {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
        }

        .zd-debug-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .zd-debug-output {
            background: #fff;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            white-space: pre-wrap;
        }

        .zd-format-toggle {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }

        .zd-format-toggle label {
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>
    <a href="/logout" class="logout-btn">Logout</a>

    <div class="container">
        <!-- Header -->
        <div class="card">
            <h1 class="title">üîç ZD Tool (Zero Defect)</h1>
            <p class="subtitle">Check your PowerPoint presentations for spelling mistakes, grammar issues, and logic inconsistencies</p>

            <div style="text-align: center; margin-bottom: 20px;">
                <a href="/dashboard" class="btn" style="display: inline-block; width: auto; background: #6c757d;">
                    ‚Üê Back to Dashboard
                </a>
            </div>
        </div>

        <!-- Upload Form -->
        <div class="card" id="uploadForm">
            <h2>üìÑ Upload PowerPoint File</h2>

            <form id="zdUploadForm" enctype="multipart/form-data">
                <div class="zd-form-group">
                    <label>Select PowerPoint File (.pptx)</label>
                    <div class="zd-file-input-wrapper">
                        <div class="zd-file-input" id="fileDropZone">
                            <input type="file" id="pptFile" name="ppt_file" accept=".pptx" style="display: none;">
                            <div id="fileSelectText">
                                üìÅ Click to select or drag & drop your .pptx file here
                            </div>
                        </div>
                    </div>
                </div>

                <div class="zd-form-group">
                    <label>Analysis Mode</label>
                    <div class="zd-mode-selection">
                        <div class="zd-mode-card selected" data-mode="fast">
                            <h4>‚ö° Fast Mode</h4>
                            <p>4,000-6,500 words per batch<br>Up to 10 pages per chunk<br>Lower cost, faster processing</p>
                        </div>
                        <div class="zd-mode-card" data-mode="precise">
                            <h4>üéØ Precise Mode</h4>
                            <p>2,500-4,000 words per batch<br>Up to 5 pages per chunk<br>More thorough cross-page logic checking</p>
                        </div>
                    </div>
                </div>

                <div class="zd-form-group">
                    <label>AI Model</label>
                    <div class="zd-model-selection">
                        <select id="modelSelect" name="model">
                            <option value="gpt-5">GPT-5 (Recommended)</option>
                            <option value="gpt-5-thinking">GPT-5 Thinking</option>
                            <option value="gpt-4.5">GPT-4.5</option>
                            <option value="gpt-5-pro">GPT-5 Pro</option>
                            <option value="gpt-4">GPT-4</option>
                        </select>
                    </div>
                </div>

                <button type="submit" class="btn" id="startAnalysisBtn" disabled>
                    üöÄ Start ZD Analysis
                </button>
            </form>
        </div>

        <!-- Progress Display -->
        <div class="card zd-progress-container" id="progressContainer">
            <h2>üìä Analysis Progress</h2>

            <div class="zd-status-display">
                <div class="zd-progress-bar">
                    <div class="zd-progress-fill" id="progressFill"></div>
                </div>
                <div id="statusMessage">Initializing...</div>
                <div id="progressText">0%</div>
                <button class="btn btn-small" onclick="toggleDebugSection()" style="margin-top: 10px;">
                    üêõ Toggle Debug
                </button>
            </div>

            <div id="chunksInfo" class="zd-chunks-info"></div>

            <!-- Debug Section -->
            <div class="zd-debug-section" id="debugSection" style="display: none;">
                <h3>üêõ Debug Information</h3>
                <div class="zd-debug-buttons">
                    <button class="btn btn-small" onclick="loadDebugInfo()">Load Debug Info</button>
                    <button class="btn btn-small" onclick="loadRawResults()">Load Raw Results</button>
                    <button class="btn btn-small" onclick="testParseResults()">üß™ Test Parse</button>
                    <button class="btn btn-small" onclick="clearDebugOutput()">Clear</button>
                    <button class="btn btn-small" onclick="toggleDebugSection()">Hide Debug</button>
                </div>
                <div class="zd-debug-output" id="debugOutput">Click "Load Debug Info" to see detailed information...</div>
            </div>
        </div>

        <!-- Results Display -->
        <div class="card zd-results-container" id="resultsContainer">
            <div class="zd-results-header">
                <h2>üìã Analysis Results</h2>
                <div class="zd-export-buttons">
                    <button class="btn btn-small" id="exportCsvBtn">üìä Export CSV</button>
                    <button class="btn btn-small" id="exportExcelBtn">üìà Export Excel</button>
                </div>
            </div>

            <div id="resultsStats" style="margin-bottom: 15px;"></div>

            <div class="zd-filter-controls">
                <label>
                    <input type="checkbox" id="filterIssuesOnly" checked>
                    Show only pages with issues
                </label>
                <label>
                    <input type="checkbox" id="filterLogicOnly">
                    Show only logic issues
                </label>
                <button class="btn btn-small" onclick="forceShowDebugInfo()" style="margin-left: 15px;">
                    üîç Force Debug
                </button>
            </div>

            <div id="resultsTableContainer">
                <table class="zd-results-table" id="resultsTable">
                    <thead>
                        <tr>
                            <th>Page</th>
                            <th>Spelling Mistakes</th>
                            <th>Grammar/Wording Issues</th>
                            <th>Logic Inconsistencies</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        let currentJobId = null;
        let currentMode = 'fast';
        let statusPollInterval = null;

        // File upload handling
        const fileInput = document.getElementById('pptFile');
        const fileDropZone = document.getElementById('fileDropZone');
        const fileSelectText = document.getElementById('fileSelectText');
        const startAnalysisBtn = document.getElementById('startAnalysisBtn');

        fileDropZone.addEventListener('click', () => fileInput.click());

        fileDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileDropZone.classList.add('dragover');
        });

        fileDropZone.addEventListener('dragleave', () => {
            fileDropZone.classList.remove('dragover');
        });

        fileDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            fileDropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                fileInput.files = files;
                updateFileDisplay();
            }
        });

        fileInput.addEventListener('change', updateFileDisplay);

        function updateFileDisplay() {
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                fileSelectText.innerHTML = `üìÑ ${file.name} (${formatFileSize(file.size)})`;
                startAnalysisBtn.disabled = false;
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Mode selection
        document.querySelectorAll('.zd-mode-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('.zd-mode-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                currentMode = card.dataset.mode;
            });
        });

        // Form submission
        document.getElementById('zdUploadForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            await startAnalysis();
        });

        async function startAnalysis() {
            try {
                // Step 1: Upload file
                const formData = new FormData();
                formData.append('ppt_file', fileInput.files[0]);

                const uploadResponse = await fetch('/api/zd/jobs', {
                    method: 'POST',
                    body: formData
                });

                const uploadResult = await uploadResponse.json();

                if (!uploadResult.success) {
                    throw new Error(uploadResult.error);
                }

                currentJobId = uploadResult.job_id;

                // Step 2: Start analysis
                const analysisResponse = await fetch(`/api/zd/jobs/${currentJobId}/run`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        mode: currentMode,
                        model: document.getElementById('modelSelect').value
                    })
                });

                const analysisResult = await analysisResponse.json();

                if (!analysisResult.success) {
                    throw new Error(analysisResult.error);
                }

                // Show progress and start polling
                showProgress(analysisResult);
                startStatusPolling();

            } catch (error) {
                alert(`Analysis failed: ${error.message}`);
            }
        }

        function showProgress(data) {
            document.getElementById('uploadForm').style.display = 'none';
            document.getElementById('progressContainer').style.display = 'block';

            if (data.stats) {
                document.getElementById('statusMessage').textContent =
                    `Analyzing ${data.stats.total_slides} slides (${data.stats.total_words} words) in ${data.total_chunks} chunks`;
            }
        }

        function startStatusPolling() {
            if (statusPollInterval) clearInterval(statusPollInterval);

            statusPollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/zd/jobs/${currentJobId}`);
                    const status = await response.json();

                    updateProgressDisplay(status);

                    if (status.status === 'done') {
                        clearInterval(statusPollInterval);
                        console.log('[DEBUG] Analysis completed, loading results...');

                        // Keep debug panel visible if it was open
                        const debugSection = document.getElementById('debugSection');
                        const wasDebugVisible = debugSection && debugSection.style.display !== 'none';

                        await loadResults();

                        // Restore debug panel visibility
                        if (wasDebugVisible && debugSection) {
                            debugSection.style.display = 'block';
                        }
                    } else if (status.status === 'error') {
                        clearInterval(statusPollInterval);
                        console.error('[DEBUG] Analysis failed:', status.error);

                        // Show error in progress container instead of hiding everything
                        const statusMessage = document.getElementById('statusMessage');
                        if (statusMessage) {
                            statusMessage.textContent = `Analysis failed: ${status.error}`;
                            statusMessage.style.color = '#dc3545';
                        }

                        alert(`Analysis failed: ${status.error}`);
                    }
                } catch (error) {
                    console.error('Error polling status:', error);
                }
            }, 2000);
        }

        function updateProgressDisplay(status) {
            const progressFill = document.getElementById('progressFill');
            const statusMessage = document.getElementById('statusMessage');
            const progressText = document.getElementById('progressText');

            progressFill.style.width = `${status.progress || 0}%`;
            progressText.textContent = `${status.progress || 0}%`;

            const statusMessages = {
                'parsing': 'Parsing PowerPoint file...',
                'chunking': 'Dividing content into chunks...',
                'prompting': 'Sending chunks to AI...',
                'thinking': 'AI is analyzing content...',
                'merging': 'Merging results...'
            };

            statusMessage.textContent = statusMessages[status.status] || status.status;

            updateChunksDisplay(status);
        }

        function updateChunksDisplay(status) {
            const chunksInfo = document.getElementById('chunksInfo');

            if (status.chunk_details) {
                // Check for new chunks that don't have UI sections yet
                Object.keys(status.chunk_details).forEach(chunkId => {
                    const existingSection = document.getElementById(`chunk-${chunkId}`);
                    if (!existingSection) {
                        // Create section for this new chunk
                        createChunkSection(chunkId, status.chunk_details[chunkId]);
                    }
                });

                // Update all existing chunk sections
                updateChunkSections(status.chunk_details);
            }
        }

        function createChunkSections(chunkDetails) {
            const chunksInfo = document.getElementById('chunksInfo');
            chunksInfo.innerHTML = '';

            // Sort chunks by chunk_id for consistent ordering
            const sortedChunks = Object.entries(chunkDetails).sort((a, b) => a[0].localeCompare(b[0]));

            sortedChunks.forEach(([chunkId, chunkData]) => {
                const chunkSection = document.createElement('div');
                chunkSection.className = 'zd-chunk-section';
                chunkSection.id = `chunk-${chunkId}`;

                const statusIcon = getStatusIcon(chunkData.status);
                const statusText = getStatusText(chunkData.status);

                chunkSection.innerHTML = `
                    <div class="zd-chunk-header ${chunkData.status}" onclick="toggleChunkDetails('${chunkId}')">
                        <div class="zd-chunk-title">
                            ${statusIcon} Chunk ${chunkId.replace('ck_', '')} (Pages ${chunkData.page_start}-${chunkData.page_end})
                        </div>
                        <div class="zd-chunk-status">
                            <span class="zd-chunk-progress">${chunkData.ai_progress || statusText}</span>
                            ${chunkData.status === 'failed' ? `<button class="zd-retry-btn" onclick="retryChunk('${chunkId}', event)">Retry</button>` : ''}
                            <span class="zd-chunk-toggle" id="toggle-${chunkId}">‚ñº</span>
                        </div>
                    </div>
                    <div class="zd-chunk-details" id="details-${chunkId}">
                        <div class="zd-chunk-info">
                            <div class="zd-chunk-info-item">
                                <strong>Pages:</strong> ${chunkData.page_start} - ${chunkData.page_end}<br>
                                <strong>Word Count:</strong> ${chunkData.word_count || 'N/A'}
                            </div>
                            <div class="zd-chunk-info-item">
                                <strong>Status:</strong> ${statusText}<br>
                                <strong>Started:</strong> ${formatTime(chunkData.start_time)}
                            </div>
                        </div>
                        ${chunkData.error ? `<div style="color: #dc3545; margin-bottom: 10px;"><strong>Error:</strong> ${chunkData.error}</div>` : ''}
                        <div>
                            <strong>AI Streaming Output:</strong>
                            <div class="zd-format-toggle">
                                <label>
                                    <input type="radio" name="format-${chunkId}" value="raw" checked onchange="toggleOutputFormat('${chunkId}', 'raw')">
                                    Raw
                                </label>
                                <label>
                                    <input type="radio" name="format-${chunkId}" value="markdown" onchange="toggleOutputFormat('${chunkId}', 'markdown')">
                                    Markdown
                                </label>
                            </div>
                            <div class="zd-streaming-output ${chunkData.streaming_output ? '' : 'empty'}" id="streaming-${chunkId}">
                                ${chunkData.streaming_output || 'No output yet...'}
                            </div>
                        </div>
                        <div class="zd-chunk-timing" id="timing-${chunkId}">
                            ${getTimingInfo(chunkData)}
                        </div>
                    </div>
                `;

                chunksInfo.appendChild(chunkSection);
            });
        }

        function createChunkSection(chunkId, chunkData) {
            const chunksInfo = document.getElementById('chunksInfo');

            const chunkSection = document.createElement('div');
            chunkSection.className = 'zd-chunk-section';
            chunkSection.id = `chunk-${chunkId}`;

            const statusIcon = getStatusIcon(chunkData.status);
            const statusText = getStatusText(chunkData.status);

            chunkSection.innerHTML = `
                <div class="zd-chunk-header ${chunkData.status}" onclick="toggleChunkDetails('${chunkId}')">
                    <div class="zd-chunk-title">
                        ${statusIcon} Chunk ${chunkId.replace('ck_', '')} (Pages ${chunkData.page_start}-${chunkData.page_end})
                    </div>
                    <div class="zd-chunk-status">
                        <span class="zd-chunk-progress">${chunkData.ai_progress || statusText}</span>
                        ${chunkData.status === 'failed' ? `<button class="zd-retry-btn" onclick="retryChunk('${chunkId}', event)">Retry</button>` : ''}
                        <span class="zd-chunk-toggle" id="toggle-${chunkId}">‚ñº</span>
                    </div>
                </div>
                <div class="zd-chunk-details" id="details-${chunkId}">
                    <div class="zd-chunk-info">
                        <div class="zd-chunk-info-item">
                            <strong>Pages:</strong> ${chunkData.page_start} - ${chunkData.page_end}<br>
                            <strong>Word Count:</strong> ${chunkData.word_count || 'N/A'}
                        </div>
                        <div class="zd-chunk-info-item">
                            <strong>Status:</strong> ${statusText}<br>
                            <strong>Started:</strong> ${formatTime(chunkData.start_time)}
                        </div>
                    </div>
                    ${chunkData.error ? `<div style="color: #dc3545; margin-bottom: 10px;"><strong>Error:</strong> ${chunkData.error}</div>` : ''}
                    <div>
                        <strong>AI Streaming Output:</strong>
                        <div class="zd-format-toggle">
                            <label>
                                <input type="radio" name="format-${chunkId}" value="raw" checked onchange="toggleOutputFormat('${chunkId}', 'raw')">
                                Raw
                            </label>
                            <label>
                                <input type="radio" name="format-${chunkId}" value="markdown" onchange="toggleOutputFormat('${chunkId}', 'markdown')">
                                Markdown
                            </label>
                        </div>
                        <div class="zd-streaming-output ${chunkData.streaming_output ? '' : 'empty'}" id="streaming-${chunkId}">
                            ${chunkData.streaming_output || 'No output yet...'}
                        </div>
                    </div>
                    <div class="zd-chunk-timing" id="timing-${chunkId}">
                        ${getTimingInfo(chunkData)}
                    </div>
                </div>
            `;

            // Insert the section in the correct position (sorted by chunk_id)
            const existingSections = Array.from(chunksInfo.children);
            const insertIndex = existingSections.findIndex(section => {
                const existingId = section.id.replace('chunk-', '');
                return chunkId.localeCompare(existingId) < 0;
            });

            if (insertIndex === -1) {
                chunksInfo.appendChild(chunkSection);
            } else {
                chunksInfo.insertBefore(chunkSection, existingSections[insertIndex]);
            }
        }

        function updateChunkSections(chunkDetails) {
            Object.entries(chunkDetails).forEach(([chunkId, chunkData]) => {
                const header = document.querySelector(`#chunk-${chunkId} .zd-chunk-header`);
                const progressSpan = document.getElementById(`chunk-${chunkId}`) ?
                    document.querySelector(`#chunk-${chunkId} .zd-chunk-progress`) : null;
                const streamingOutput = document.getElementById(`streaming-${chunkId}`);
                const timing = document.getElementById(`timing-${chunkId}`);

                if (header) {
                    // Update header status class
                    header.className = `zd-chunk-header ${chunkData.status}`;
                }

                if (progressSpan) {
                    // Update progress text
                    progressSpan.textContent = chunkData.ai_progress || getStatusText(chunkData.status);
                }

                if (streamingOutput) {
                    // Update streaming output
                    if (chunkData.streaming_output) {
                        // Check current format mode
                        const formatRadios = document.querySelectorAll(`input[name="format-${chunkId}"]`);
                        const isMarkdown = Array.from(formatRadios).find(r => r.checked)?.value === 'markdown';

                        if (isMarkdown && typeof marked !== 'undefined') {
                            streamingOutput.innerHTML = marked.parse(chunkData.streaming_output);
                            streamingOutput.className = 'zd-streaming-output markdown';
                        } else {
                            streamingOutput.textContent = chunkData.streaming_output;
                            streamingOutput.className = 'zd-streaming-output';
                        }
                        // Auto-scroll to bottom
                        streamingOutput.scrollTop = streamingOutput.scrollHeight;
                    } else {
                        streamingOutput.textContent = 'No output yet...';
                        streamingOutput.className = 'zd-streaming-output empty';
                    }
                }

                if (timing) {
                    // Update timing information
                    timing.innerHTML = getTimingInfo(chunkData);
                }
            });
        }

        function getStatusIcon(status) {
            const icons = {
                'starting': 'üîÑ',
                'sending': 'üì§',
                'processing': '‚ö°',
                'completed': '‚úÖ',
                'failed': '‚ùå'
            };
            return icons[status] || '‚è≥';
        }

        function getStatusText(status) {
            const texts = {
                'starting': 'Starting...',
                'sending': 'Sending to AI...',
                'processing': 'AI Processing...',
                'completed': 'Completed',
                'failed': 'Failed'
            };
            return texts[status] || 'Unknown';
        }

        function formatTime(timestamp) {
            if (!timestamp) return 'N/A';
            const date = new Date(timestamp * 1000);
            return date.toLocaleTimeString();
        }

        function getTimingInfo(chunkData) {
            if (!chunkData.start_time) return '';

            const startTime = new Date(chunkData.start_time * 1000).toLocaleTimeString();
            let timingHtml = `Started: ${startTime}`;

            if (chunkData.completion_time) {
                const completionTime = new Date(chunkData.completion_time * 1000).toLocaleTimeString();
                const duration = ((chunkData.completion_time - chunkData.start_time) / 1000).toFixed(1);
                timingHtml += ` | Completed: ${completionTime} | Duration: ${duration}s`;
            } else if (chunkData.start_time) {
                const elapsed = ((Date.now() / 1000) - chunkData.start_time).toFixed(1);
                timingHtml += ` | Elapsed: ${elapsed}s`;
            }

            return timingHtml;
        }

        function toggleChunkDetails(chunkId) {
            const details = document.getElementById(`details-${chunkId}`);
            const toggle = document.getElementById(`toggle-${chunkId}`);

            if (details.classList.contains('expanded')) {
                details.classList.remove('expanded');
                toggle.classList.remove('expanded');
            } else {
                details.classList.add('expanded');
                toggle.classList.add('expanded');
            }
        }

        function retryChunk(chunkId, event) {
            event.stopPropagation(); // Prevent toggle

            if (confirm(`Retry chunk ${chunkId.replace('ck_', '')}?`)) {
                fetch(`/api/zd/jobs/${currentJobId}/chunks/${chunkId}/retry`, {
                    method: 'POST'
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Remove retry button and update status
                        const retryBtn = event.target;
                        retryBtn.style.display = 'none';
                    } else {
                        alert(`Retry failed: ${data.error}`);
                    }
                })
                .catch(error => {
                    alert(`Retry failed: ${error.message}`);
                });
            }
        }

        function toggleOutputFormat(chunkId, format) {
            const streamingOutput = document.getElementById(`streaming-${chunkId}`);
            if (!streamingOutput) return;

            const content = streamingOutput.textContent || streamingOutput.innerHTML;

            if (format === 'markdown' && typeof marked !== 'undefined' && content !== 'No output yet...') {
                streamingOutput.innerHTML = marked.parse(content);
                streamingOutput.className = 'zd-streaming-output markdown';
            } else {
                streamingOutput.textContent = content;
                streamingOutput.className = 'zd-streaming-output';
            }
        }

        function toggleDebugSection() {
            const debugSection = document.getElementById('debugSection');
            const isVisible = debugSection.style.display !== 'none';
            debugSection.style.display = isVisible ? 'none' : 'block';

            if (!isVisible) {
                loadDebugInfo();
            }
        }

        async function loadDebugInfo() {
            if (!currentJobId) {
                document.getElementById('debugOutput').textContent = 'No active job to debug.';
                return;
            }

            try {
                const response = await fetch(`/api/zd/jobs/${currentJobId}/debug`);
                const debugData = await response.json();

                document.getElementById('debugOutput').textContent = JSON.stringify(debugData, null, 2);
            } catch (error) {
                document.getElementById('debugOutput').textContent = `Error loading debug info: ${error.message}`;
            }
        }

        async function loadRawResults() {
            if (!currentJobId) {
                document.getElementById('debugOutput').textContent = 'No active job to debug.';
                return;
            }

            try {
                const response = await fetch(`/api/zd/jobs/${currentJobId}/result?include_raw=true`);
                const rawData = await response.json();

                document.getElementById('debugOutput').textContent = JSON.stringify(rawData, null, 2);
            } catch (error) {
                document.getElementById('debugOutput').textContent = `Error loading raw results: ${error.message}`;
            }
        }

        async function testParseResults() {
            if (!currentJobId) {
                document.getElementById('debugOutput').textContent = 'No active job to test parsing.';
                return;
            }

            try {
                const response = await fetch(`/api/zd/jobs/${currentJobId}/test-parse`);
                const parseData = await response.json();

                let outputText = `=== PARSE TEST RESULTS ===\n\n`;
                outputText += `Job ID: ${parseData.job_id}\n`;
                outputText += `Total Chunks: ${parseData.total_chunks}\n\n`;

                for (const [chunkId, testResult] of Object.entries(parseData.test_results || {})) {
                    outputText += `--- CHUNK ${chunkId} ---\n`;
                    outputText += `Original Length: ${testResult.original_length} chars\n`;
                    outputText += `Raw Lines: ${testResult.raw_lines_count}\n`;
                    outputText += `Parsed Rows: ${testResult.parsed_rows_count}\n`;
                    outputText += `First 200 chars: ${testResult.first_200_chars}\n`;

                    if (testResult.parsed_rows && testResult.parsed_rows.length > 0) {
                        outputText += `Sample parsed rows:\n`;
                        testResult.parsed_rows.forEach(row => {
                            outputText += `  Page ${row.page_number}: Spelling="${row.spelling}" Grammar="${row.grammar}" Logic="${row.logic}"\n`;
                        });
                    } else {
                        outputText += `‚ùå NO ROWS PARSED!\n`;
                    }
                    outputText += `\n`;
                }

                document.getElementById('debugOutput').textContent = outputText;
            } catch (error) {
                document.getElementById('debugOutput').textContent = `Error testing parse: ${error.message}`;
            }
        }

        function clearDebugOutput() {
            document.getElementById('debugOutput').textContent = 'Debug output cleared.';
        }

        async function forceShowDebugInfo() {
            // Force show debug panel
            const debugSection = document.getElementById('debugSection');
            const progressContainer = document.getElementById('progressContainer');

            if (debugSection) {
                debugSection.style.display = 'block';
            }

            if (progressContainer) {
                progressContainer.style.display = 'block';
            }

            // Load both debug info and raw results
            if (currentJobId) {
                try {
                    const [debugResponse, rawResponse] = await Promise.all([
                        fetch(`/api/zd/jobs/${currentJobId}/debug`),
                        fetch(`/api/zd/jobs/${currentJobId}/result?include_raw=true`)
                    ]);

                    const debugData = await debugResponse.json();
                    const rawData = await rawResponse.json();

                    const combinedInfo = {
                        timestamp: new Date().toISOString(),
                        job_debug_info: debugData,
                        raw_results_info: {
                            has_results: !!rawData.results,
                            results_count: rawData.results ? rawData.results.length : 0,
                            has_raw_chunk_results: !!rawData.raw_chunk_results,
                            raw_chunks_count: rawData.raw_chunk_results ? Object.keys(rawData.raw_chunk_results).length : 0
                        },
                        full_raw_data: rawData
                    };

                    document.getElementById('debugOutput').textContent = JSON.stringify(combinedInfo, null, 2);
                } catch (error) {
                    document.getElementById('debugOutput').textContent = `Force debug error: ${error.message}`;
                }
            } else {
                document.getElementById('debugOutput').textContent = 'No current job ID available for debugging.';
            }
        }

        async function loadResults() {
            console.log('[DEBUG] Loading results for job:', currentJobId);

            try {
                const response = await fetch(`/api/zd/jobs/${currentJobId}/result`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('[DEBUG] Results loaded:', data);

                if (data.error) {
                    throw new Error(data.error);
                }

                displayResults(data);

            } catch (error) {
                console.error('[DEBUG] Error loading results:', error);
                alert(`Failed to load results: ${error.message}`);

                // Keep progress container visible and show error
                const statusMessage = document.getElementById('statusMessage');
                if (statusMessage) {
                    statusMessage.textContent = `Error loading results: ${error.message}`;
                    statusMessage.style.color = '#dc3545';
                }
            }
        }

        function displayResults(data) {
            // Hide progress display but keep the container visible so debug panel remains
            document.getElementById('progressFill').style.width = '100%';
            document.getElementById('statusMessage').textContent = 'Analysis Complete!';
            document.getElementById('progressText').textContent = '100%';

            // Show results container
            document.getElementById('resultsContainer').style.display = 'block';

            // Update stats
            const statsDiv = document.getElementById('resultsStats');
            if (data.stats) {
                const issuesCount = data.results ? data.results.filter(r => r.spelling || r.grammar || r.logic).length : 0;
                statsDiv.innerHTML = `
                    <strong>Analysis Complete!</strong>
                    Processed ${data.stats.total_slides} slides (${data.stats.total_words} words).
                    Found issues on ${issuesCount} pages.
                `;
            } else {
                statsDiv.innerHTML = `
                    <strong>Analysis Complete!</strong>
                    Results processed successfully.
                `;
            }

            console.log('[DEBUG] Displaying results:', {
                hasStats: !!data.stats,
                resultsCount: data.results ? data.results.length : 0,
                issuesCount: data.results ? data.results.filter(r => r.spelling || r.grammar || r.logic).length : 0
            });

            // Populate table
            populateResultsTable(data.results);

            // Setup export buttons
            setupExportButtons();
        }

        function populateResultsTable(results) {
            const tbody = document.getElementById('resultsTableBody');
            if (!tbody) {
                console.error('[DEBUG] Results table body not found!');
                return;
            }

            tbody.innerHTML = '';

            if (!results || results.length === 0) {
                console.log('[DEBUG] No results to display');
                const tr = document.createElement('tr');
                tr.innerHTML = '<td colspan="4" style="text-align: center; color: #6c757d; font-style: italic;">No results found. Check debug panel for details.</td>';
                tbody.appendChild(tr);
                return;
            }

            console.log('[DEBUG] Populating table with', results.length, 'results');

            results.forEach((row, index) => {
                const tr = document.createElement('tr');

                const hasIssues = row.spelling || row.grammar || row.logic;
                if (!hasIssues) {
                    tr.style.opacity = '0.6';
                }

                tr.innerHTML = `
                    <td class="zd-page-number">${row.page_number || 'N/A'}</td>
                    <td class="zd-issues-cell">${row.spelling || '<span class="zd-no-issues">‚Äî</span>'}</td>
                    <td class="zd-issues-cell">${row.grammar || '<span class="zd-no-issues">‚Äî</span>'}</td>
                    <td class="zd-issues-cell ${row.logic ? 'zd-logic-issue' : ''}">${row.logic || '<span class="zd-no-issues">‚Äî</span>'}</td>
                `;

                tbody.appendChild(tr);
            });

            console.log('[DEBUG] Table populated successfully');

            // Setup filtering
            setupResultsFiltering(results);
        }

        function setupResultsFiltering(results) {
            const filterIssuesOnly = document.getElementById('filterIssuesOnly');
            const filterLogicOnly = document.getElementById('filterLogicOnly');

            function applyFilters() {
                const rows = document.querySelectorAll('#resultsTableBody tr');

                rows.forEach((row, index) => {
                    const result = results[index];
                    let show = true;

                    if (filterIssuesOnly.checked) {
                        const hasIssues = result.spelling || result.grammar || result.logic;
                        if (!hasIssues) show = false;
                    }

                    if (filterLogicOnly.checked) {
                        if (!result.logic) show = false;
                    }

                    row.style.display = show ? '' : 'none';
                });
            }

            filterIssuesOnly.addEventListener('change', applyFilters);
            filterLogicOnly.addEventListener('change', applyFilters);

            // Apply initial filter
            applyFilters();
        }

        function setupExportButtons() {
            document.getElementById('exportCsvBtn').addEventListener('click', () => {
                window.open(`/api/zd/jobs/${currentJobId}/result?format=csv`);
            });

            document.getElementById('exportExcelBtn').addEventListener('click', () => {
                window.open(`/api/zd/jobs/${currentJobId}/result?format=xlsx`);
            });
        }
    </script>
</body>
</html>